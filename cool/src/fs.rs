use crate::{GlobalArrayAssigned, OclBlock, DEFAULT_GLOBAL_ARRAY_COUNT, DEFAULT_VECTOR_SIZE};
use lazy_static::lazy_static;
use napi::bindgen_prelude::{BigInt, Buffer};
use napi::{Error as NapiError, Status};
use std::collections::HashMap;
use std::sync::Mutex;

// static GLOBAL_OCL_BLOCK: Mutex<OclBlock> = Mutex::new(OclBlock::new(
//   DEFAULT_VECTOR_SIZE,
//   DEFAULT_GLOBAL_ARRAY_COUNT,
// ));

pub type GlobalCacheMap = HashMap<String, GlobalArrayAssigned>;

lazy_static! {
  static ref GLOBAL_OCL_BLOCK: Mutex<OclBlock> = Mutex::new(OclBlock::new(
    DEFAULT_VECTOR_SIZE,
    DEFAULT_GLOBAL_ARRAY_COUNT,
  ));
}

lazy_static! {
  static ref GLOBAL_CACHE: Mutex<GlobalCacheMap> = Mutex::new(HashMap::new());
}

#[napi]
pub fn write_file_sync(file: String, data: Buffer) -> napi::Result<()> {
  let mut ocl_block = GLOBAL_OCL_BLOCK.lock().unwrap();
  let mut global_cache = GLOBAL_CACHE.lock().unwrap();

  let size = BigInt::from(data.len() as u64);
  let index = ocl_block.enqueue_buffer(data, None)?;

  global_cache.insert(file, GlobalArrayAssigned { index, size });

  Ok(())
}

// conflicts with (node-binddgen) autogenerated file index.js - readFileSync

#[napi]
pub fn read_file_synchronous(file: String) -> napi::Result<Buffer> {
  let ocl_block = GLOBAL_OCL_BLOCK.lock().unwrap();
  let global_cache = GLOBAL_CACHE.lock().unwrap();

  match global_cache.get(file.as_str()) {
    Some(v) => Ok(ocl_block.dequeue_buffer(v.index)?),
    None => Err(NapiError::new(
      Status::Unknown,
      format!("ENOENT: no such file or directory, open '{file}'"),
    )),
  }
}

// conflicts with (node-binddgen) autogenerated file index.js - existsSync

#[napi]
pub fn exists_synchronous(file: String) -> napi::Result<bool> {
  let global_cache = GLOBAL_CACHE.lock().unwrap();
  Ok(global_cache.contains_key(file.as_str()))
}

#[napi(js_name = "FileHandle")]
#[derive(Debug, Clone)]
pub struct FileHandle {
  path: String,
  fd: u32,
}

#[napi]
impl FileHandle {
  #[napi(factory)]
  pub fn open(path: String) -> napi::Result<Self> {
    // TODO open flags
    // let mut ocl_block = GLOBAL_OCL_BLOCK.lock().unwrap();
    let global_cache = GLOBAL_CACHE.lock().unwrap();

    match global_cache.get(path.as_str()) {
      Some(v) => {
        // TODO open flags
        // let index = ocl_block.inner.assign_global_array_index()?;
        //
        // global_cache.insert(path, GlobalArrayAssigned {
        //     index,
        //     size: BigInt::from(0 as u64),
        // });
        Ok(FileHandle { path, fd: v.index })
      }
      None => Err(NapiError::new(
        Status::Unknown,
        format!("ENOENT: no such file or directory, open '{path}'"),
      )),
    }
  }

  #[napi]
  pub fn fd(&self) -> napi::Result<u32> {
    Ok(self.fd)
  }

  #[napi]
  pub async fn write_file(&self, data: Buffer) -> napi::Result<()> {
    let mut ocl_block = GLOBAL_OCL_BLOCK.lock().unwrap();
    let mut global_cache = GLOBAL_CACHE.lock().unwrap();

    let size = BigInt::from(data.len() as u64);
    ocl_block.enqueue_buffer(data, Some(self.fd))?;

    global_cache.get_mut(self.path.as_str()).unwrap().size = size;

    Ok(())
  }

  #[napi]
  pub async fn read_file(&self) -> napi::Result<Buffer> {
    let ocl_block = GLOBAL_OCL_BLOCK.lock().unwrap();
    Ok(ocl_block.dequeue_buffer(self.fd)?)
  }
}

#[napi]
pub fn cache() -> napi::Result<GlobalCacheMap> {
  let global_cache = GLOBAL_CACHE.lock().unwrap();
  Ok(global_cache.clone())
}

#[napi]
pub fn ocl_cache() -> napi::Result<Vec<GlobalArrayAssigned>> {
  let ocl_block = GLOBAL_OCL_BLOCK.lock().unwrap();
  ocl_block.get_global_arrays()
}
