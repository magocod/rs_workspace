use cl::ocl_fs::{ocl_cache, ocl_initialize, OclFile};
use napi::bindgen_prelude::Buffer;
use std::io::{BufRead, BufReader, Write};

#[napi]
pub fn write_file_sync(file: String, data: Buffer) -> napi::Result<()> {
  let mut f = OclFile::create(file)?;
  f.write(data.as_ref())?;
  Ok(())
}

// conflicts with (node-binddgen) autogenerated file index.js - readFileSync

#[napi]
pub fn read_file_synchronous(file: String) -> napi::Result<Buffer> {
  let f = OclFile::open(file)?;
  let mut reader = BufReader::new(f);
  Ok(Buffer::from(reader.fill_buf()?))
}

// conflicts with (node-binddgen) autogenerated file index.js - existsSync

#[napi]
pub fn exists_synchronous(file: String) -> napi::Result<bool> {
  Ok(OclFile::open(file).is_ok())
}

#[napi(js_name = "FileHandle")]
#[derive(Debug)]
pub struct FileHandle {
  inner: OclFile,
}

#[napi]
impl FileHandle {
  #[napi(factory)]
  pub fn open(path: String) -> napi::Result<Self> {
    // TODO open flags
    let f = OclFile::open(path)?;
    Ok(FileHandle { inner: f })
  }

  #[napi]
  pub fn fd(&self) -> napi::Result<u32> {
    Ok(self.inner.global_array_index())
  }

  #[napi]
  pub async unsafe fn write_file(&mut self, data: Buffer) -> napi::Result<()> {
    self.inner.write(data.as_ref())?;
    Ok(())
  }

  #[napi]
  pub async fn read_file(&self) -> napi::Result<Buffer> {
    let mut reader = BufReader::new(self.inner.clone());
    Ok(Buffer::from(reader.fill_buf()?))
  }
}

#[napi]
pub fn cache() -> napi::Result<()> {
  ocl_cache()?;
  Ok(())
}

#[napi]
pub fn initialize() -> napi::Result<()> {
  ocl_initialize(true);
  Ok(())
}
